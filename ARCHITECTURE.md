# Racing App Architecture

This document describes the **current**, working architecture of the racing app.

## Tech Stack

- **Backend**: Node.js (via .nvmrc), TypeScript, Express, Socket.IO
- **Frontend**: React + Vite (JavaScript), Socket.IO client
- **Data**:
  - In-memory race state per **lobby** (multiple concurrent races).
  - PostgreSQL for users, cars, and race records.
  - JSON log files on disk for race replays.

---

## Core Concepts & Identifiers

- **Lobby ID (UUID)**
  - Created when an admin creates a race.
  - Used as the canonical race identifier across the system:
    - Primary key `id` in the `races` table.
    - Socket.IO room name (`io.to(lobbyId)` and `socket.join(lobbyId)`).
    - URL segment for `/race/:id` (read‑only viewer).
    - Written into race logs as `lobbyId`.
  - New log files are named `<lobbyId>.json`.

- **Internal raceId (per simulation)**
  - Generated by `RaceManager` when a race run starts (e.g. `race-<timestamp>-<counter>`).
  - Used only inside the simulation and persisted into logs as `raceId` for debugging.
  - Not used in URLs or DB relations.

---

## Backend

### RaceManager (backend/src/race.ts)

- Holds per-lobby in-memory state:
  - `cars`, `durationMs`, `status` (`idle` | `ready` | `running` | `finished`), timestamps, current `raceId`.
  - `lobbyId`: the external UUID for that lobby, set by the server.
- Behavior:
  - `configure(durationMs)`
    - Sets `durationMs`.
    - Transitions `idle → ready`.
  - `addCar(car)`
    - Adds cars while not running.
    - First car added when idle also transitions to `ready`.
  - `start(onTick, onFinished)`
    - Valid only when not already running and there is at least one car.
    - Computes per‑car performance based on `acceleration`, `topSpeed`, `handling` and randomness.
    - Starts a ~200ms tick interval that advances `progress` in `[0, 1]` for each car.
    - Records `finishTimeMs` when a car first hits `progress >= 1`.
    - Ends the race only when **all** cars have finished; computes final results and calls `onFinished`.
    - Sets `state.startedAt`, `state.raceId` (internal), and status `running`.
    - Appends each tick to `tickHistory` for replay.
  - `clear()`
    - Stops timers, clears cars and performance data, empties `tickHistory`.
    - Resets status to `idle` but keeps the last configured `durationMs`.
  - `persistRaceLog(results)`
    - Writes a JSON file in `backend/logs/` **only** when `currentRaceId`, `startedAt`, and `finishedAt` are set.
    - File name: `<lobbyId>.json` if `lobbyId` is set, otherwise `<currentRaceId>.json`.
    - Payload includes: `raceId` (internal), `lobbyId`, `startedAt`, `finishedAt`, `durationMs`, full `cars` array, `ticks` (history), and `results`.

### Race Collection & DB (backend/src/server.ts + setup/seed.sql)

- `races: Map<string, RaceManager>`
  - Keyed by lobby UUID.
  - Each entry is a live `RaceManager` instance.

- `createRace(initialDurationMs?, createdByUserId?)`
  - Generates a lobby UUID via `randomUUID()`.
  - Creates a `RaceManager`, sets `lobbyId` to the UUID, optionally calls `configure(initialDurationMs)`.
  - Stores it in `races` map.
  - Persists a row in `races` table:
    - `id` = lobby UUID.
    - `created_by` = user UUID (admin).
    - `status` = `idle` initially.
    - `duration_ms` = current configured duration.

- **Database schema (simplified)**
  - `users(id, name, username, password, role)`
    - `role` is `admin` or `user`.
  - `cars(id, user_id, name, color, acceleration, top_speed, handling, created_at)`
    - `user_id` FK → `users.id`.
  - `races(id, created_by, status, duration_ms, created_at, finished_at)`
    - `id` is the lobby UUID used everywhere.
    - `status` transitions through `idle` → `ready` → `running` → `finished` / `closed`.

### Socket Server (backend/src/server.ts)

All socket messages are **per lobby** and use the lobby UUID as `raceId`.

- `race:create` (admin)
  - Payload: `{ durationMs?, createdByUserId? }`.
  - Creates a new lobby + `RaceManager`, stores it in the map, persists DB row.
  - `socket.join(lobbyId)` and replies `{ raceId: lobbyId }`.
  - Emits initial `race:state` to that room.

- `race:join`
  - Payload: `{ raceId }` (the lobby UUID).
  - If the lobby exists:
    - `socket.join(raceId)`.
    - Emits `race:state` with full state.
  - If it does **not** exist:
    - Emits `race:error` → `{ raceId, message: 'Race not found' }`.

- `race:configure`
  - Payload: `{ raceId, durationMs }`.
  - Updates that lobby’s `RaceManager` and emits `race:state` to the room.

- `car:add`
  - Payload: `{ raceId, car }`.
  - Adds the car to the lobby’s `RaceManager` and emits updated `race:state`.

- `race:start`
  - Payload: `{ raceId }`.
  - Invokes `RaceManager.start` for that lobby with callbacks:
    - On tick: broadcasts `race:tick` → `{ tick: RaceTick[] }` to the room.
    - On finished:
      - Broadcasts `race:finished` → `{ results, state: { ...state, raceId } }`.
      - Emits a final `race:state` snapshot.
      - Persists DB `status = 'finished'`, `finished_at = NOW()`.
  - When race actually starts:
    - Emits `race:started` → `{ raceId, startedAt, durationMs }`.
    - Updates DB `status = 'running'`.

- `race:reset`
  - Payload: `{ raceId }`.
  - Calls `RaceManager.clear()` and emits `race:state` for that lobby.
  - Sets DB `status = 'idle'`, `finished_at = NULL`.

- `race:close`
  - Payload: `{ raceId }`.
  - Clears and removes that lobby from the `races` map.
  - Marks DB `status = 'closed'` and ensures `finished_at` is set.
  - Emits `race:closed` → `{ raceId }` to the room.

### HTTP Endpoints (backend/src/server.ts)

- Health / base
  - `/` → simple text response.

- Logs / Replays
  - `GET /logs`
    - Reads all `*.json` files from `backend/logs`.
    - Returns `{ logs: [{ file, raceId, lobbyId, startedAt, finishedAt }, ...] }`.
  - `GET /logs/:file`
    - Serves an individual log file by name (with basic validation to avoid traversal).

- Admin race inspection
  - `GET /admin/race` (and alias `/admin/races`)
    - Lists currently active lobbies from `races` map with `{ raceId, status, cars, durationMs }`.
  - `GET /admin/race/history`
    - Returns stored race rows from Postgres (finished/closed races).
  - `GET /admin/race/:raceId`
    - Returns full in‑memory state for an active race lobby, if present.

- Admin & user data
  - `GET /admin/users`
    - Lists all users.
  - `GET /admin/cars`
    - Lists all cars (with user linkage).
  - `GET /user/:userId/cars`
    - Lists cars owned by that user.
  - `POST /user/:userId/cars`
    - Creates a car for that user in the `cars` table.

### Auth & Sessions

- In‑memory session store keyed by **session ID**.
- On `/auth/login`:
  - Verifies `username`/`password` against `users` table.
  - Creates a session `{ id: sessionId, userId: dbUserId }`.
  - Sets an HttpOnly cookie (`racer_session`) with the session ID.
  - Returns a user JSON where `id` is the **DB user id**, `role` is `admin` or `user`.
- `/auth/me`
  - Reads session cookie, fetches the user, returns `{ user }` or 401 if not logged in.
- `/auth/logout`
  - Clears the session and cookie.

---

## Frontend

### Routing & Views (frontend/src/App.jsx)

- Manual path-based routing using `window.location.pathname` and local state `activeView`:
  - `/login` → shows login screen.
  - `/admin` → admin dashboard (for admin users only).
  - `/user` → user dashboard (for regular users).
  - `/race/:id` → dedicated race viewer page (read‑only, no navigation header).

- `App` behavior:
  - On boot, calls `/auth/me` with credentials to restore session.
  - Stores the `user` object in `localStorage` (`racer:user`) and state.
  - Uses `user.role` to gate access to admin routes.
  - For `/race/:id`:
    - If authenticated, sets `activeView = 'race-page'` and renders `RaceView` in read‑only mode.
    - Hides global navigation on this page.

### Admin Experience

- **AdminView / AdminDashboard**
  - Shows:
    - Active races from `/admin/race`.
    - Users from `/admin/users`.
    - Cars from `/admin/cars`.
    - Historical races from `/admin/race/history`.
  - Allows admins to:
    - Create a new race (lobby) with configurable duration.
    - Start / close specific races.
    - Inspect which users/cars are joined to each race.
    - Click **View** on a race, which opens `/race/:id` in a **new tab**.

### User Experience

- **UserDashboard**
  - Shows the current user’s profile and garage.
  - Fetches and displays the user’s cars from `/user/:userId/cars`.
  - Allows creating new cars via `POST /user/:userId/cars`.
  - Shows active races so the user can join by registering one of their cars.

### RaceView (frontend/src/components/RaceView.jsx)

RaceView has two modes: **full control** (admin/normal) and **read‑only** (`/race/:id`).

- Common behavior
  - Connects to the Socket.IO backend via shared `socket` client.
  - Listens for `race:state`, `race:started`, `race:tick`, `race:finished`, `race:error`.
  - Maintains UI state for:
    - `cars`, `raceStatus`, `durationSeconds`, `countdown`, `progressByCar`, `results`.
  - Uses `RaceMonitorAndResults` to display:
    - Track lanes with car positions and percentage complete.
    - Final results table and replay list.

- Full control mode (admin/racer view)
  - Shows `RaceSetupAndGarage`:
    - Configure race duration.
    - Create / join races.
    - Add cars (in-memory client-side + `car:add` socket event).
    - Start and reset races.
    - Open a **live race modal** showing the race.
  - Persists cars, duration, and raceId to `localStorage` under `racer:*` keys so configuration survives reloads.
  - Replay behavior:
    - Fetches `/logs` and lists available replays.
    - On selecting a replay, fetches `/logs/:file` and plays it inside `ReplayModal`.

- Read‑only mode (`/race/:id` viewer)
  - No navigation/header (handled by `App`), and no `RaceSetupAndGarage` controls.
  - Derives `raceId` (the lobby UUID) from the URL.
  - Does **not** touch `localStorage` for race configuration.
  - Socket behavior:
    - On connect or when `raceId` becomes known, emits `race:join { raceId }`.
    - Shows live ticks and countdown if the race is currently running.
    - If the backend emits `race:error` for this `raceId`, shows a banner like
      “Race with ID <id> was not found.”
  - Replay auto‑play:
    - Fetches `/logs` on mount.
    - Once logs are available, finds the latest log where `log.lobbyId === raceId`.
    - Automatically calls `startReplay(log.file)`.
    - In read-only mode, `startReplay`:
      - Sets `cars` and `results` from the log.
      - Drives `progressByCar` using logged ticks.
      - Does **not** open a modal; the race plays directly in the main track.

---

## Event / Communication Flow (Summary)

1. **Client connects**
   - Frontend establishes Socket.IO connection.
   - Backend sends `server:welcome` and, on `race:join`, a `race:state` snapshot.

2. **Admin creates + configures a race**
   - Admin UI calls socket `race:create` → backend creates lobby, DB row, `RaceManager`.
   - Admin UI then configures duration and adds cars via `race:configure` and `car:add`.

3. **Users join races**
   - Users see active races from `/admin/race`.
   - They join via a combination of HTTP (registering cars to their account) and socket events (`race:join`, `car:add` with owner metadata).

4. **Race start & progression**
   - Admin triggers `race:start { raceId }`.
   - Backend broadcasts `race:started`, then `race:tick` until all cars finish.
   - Final `race:finished` + updated `race:state` are emitted, DB is updated, and a log file is written.

5. **Reset / Close**
   - `race:reset` clears cars and results for that lobby but keeps it active.
   - `race:close` clears the lobby and removes it from the active map while keeping DB and logs for history.

6. **Replay**
   - Anywhere in the app, `/logs` is used to list past races.
   - The dedicated `/race/:id` viewer uses `lobbyId` to auto‑locate and play the correct log for that lobby.

---

## Future Directions

- Stronger auth (password hashing, proper user management, OAuth, etc.).
- Persist per‑race car participation (link cars directly to race rows in DB).
- Richer race history and analytics (filtering, stats, leaderboards).
- More advanced visuals (e.g. 3D track) backed by the same tick stream.
- Horizontal scaling of the Socket.IO + race simulation layer.

---

## Developer Reference / Quick Map

This section is meant as a one‑stop overview so the whole project logic can be understood from this file.

### Backend File Map

- `backend/src/server.ts`
  - Express app + Socket.IO server.
  - Declares all HTTP endpoints (`/auth/*`, `/admin/*`, `/user/*`, `/logs*`).
  - Manages the in‑memory `races: Map<lobbyId, RaceManager>`.
  - Wires all socket events (`race:*`, `car:add`).

- `backend/src/race.ts`
  - Defines `RaceManager`, `RaceState`, `RaceTick`, and result types.
  - Implements the race physics, ticking, and logging to disk.

- `backend/src/db.ts`
  - Simple Postgres helper (`query`) used by `server.ts`.
  - Connection details are expected via environment (e.g. `DATABASE_URL` or equivalent; see this file for exact config).

### Frontend File Map

- `frontend/src/App.jsx`
  - Root React component.
  - Handles auth bootstrap via `/auth/me` and stores `user`.
  - Implements simple path-based routing and view selection.

- `frontend/src/socket.js`
  - Creates and exports the shared Socket.IO client used by `RaceView`.

- Key components (all under `frontend/src/components/`):
  - `AppHeader.jsx` — top bar with user info, socket status, and view switch (hidden on `/race/:id`).
  - `LoginScreen.jsx` — username/password login form; calls `/auth/login`.
  - `AdminView.jsx` — fetches admin data from backend and renders `AdminDashboard`.
  - `AdminDashboard.jsx` — admin UI for active races, history, users, and cars; contains “View” buttons that open `/race/:id`.
  - `UserDashboard.jsx` — user profile + garage; wraps car CRUD and joining races.
  - `RaceView.jsx` — main race controller + viewer (full control and read‑only modes).
  - `RaceSetupAndGarage.jsx` — left panel controls (race ID, duration, add cars, start/reset, open live modal).
  - `RaceMonitorAndResults.jsx` — right panel (track lanes, countdown, results, replay list).
  - `RaceModal.jsx` — live race modal overlay for the full-control view.
  - `ReplayModal.jsx` — replay viewer modal for the full-control view.
  - `CarIcon.jsx` — small SVG car used in the race monitor.

### Local Storage Keys (Frontend)

Used only in **full control** mode; read‑only `/race/:id` ignores these keys.

- `racer:user` — cached logged‑in user object (`id`, `name`, `username`, `role`).
- `racer:cars` — list of locally configured cars for the current race setup.
- `racer:durationMs` — last configured duration in milliseconds.
- `racer:raceId` — last joined/created race lobby UUID.
- `racer:openRaceModalOnce` — flag for auto‑opening the live race modal exactly once on load.
- `racer:openReplayForRace` — flag to auto‑open a replay for a specific race (legacy / admin overlay use).

### Cookie, CORS, and Ports

- Backend
  - Default dev port: `4000`.
  - Sets `Set-Cookie: racer_session=<id>; HttpOnly; SameSite` (see `server.ts` for exact attributes).
  - CORS is configured to:
    - Allow requests from Vite dev origins (e.g. `http://localhost:5173`).
    - Allow credentials so cookies are sent by the browser.

- Frontend
  - Default dev port (Vite): `5173`.
  - All auth-protected fetches include `credentials: 'include'` so the session cookie is used.

### Replay Log Schema (for reference)

Each log file under `backend/logs/` (typically `<lobbyId>.json`) has a shape similar to:

```jsonc
{
  "raceId": "race-<timestamp>-<counter>", // internal
  "lobbyId": "<lobby-uuid>",             // external, matches /race/:id and races.id
  "startedAt": 1739812345678,
  "finishedAt": 1739812358901,
  "durationMs": 10000,
  "cars": [
    {
      "id": "car-uuid",
      "name": "Thunderbolt GT",
      "color": "#ef4444",
      "attributes": {
        "acceleration": 5.5,
        "topSpeed": 220,
        "handling": 0.8
      }
    }
  ],
  "ticks": [
    {
      "at": 0,
      "tick": [ { "carId": "car-uuid", "name": "Thunderbolt GT", "color": "#ef4444", "progress": 0 } ]
    },
    {
      "at": 200,
      "tick": [ { "carId": "car-uuid", "name": "Thunderbolt GT", "color": "#ef4444", "progress": 0.12 } ]
    }
  ],
  "results": [
    {
      "carId": "car-uuid",
      "name": "Thunderbolt GT",
      "color": "#ef4444",
      "finalSpeed": 180.5,
      "finishTimeMs": 9876,
      "rank": 1
    }
  ]
}
```

RaceView’s read‑only mode uses `lobbyId` from `/logs`, then streams `ticks[*].tick[*].progress` into the main track visualization.

